## 🚦 同步 vs 异步：最直白的解释

### 🟢 同步（Synchronous）
一步接一步执行，每一步都要等前面完成才能继续。

```js
console.log("1");
console.log("2");
console.log("3");
```

输出：
```
1
2
3
```

---

### 🔵 异步（Asynchronous）
你可以“先安排好事情”，然后“等它做完再回来处理”。

```js
console.log("1");
setTimeout(() => console.log("2"), 1000);
console.log("3");
```

输出：
```
1
3
2
```

💡 `setTimeout` 是异步的，安排1秒后再执行，所以 `3` 会先输出。

---

## 🚀 在 Ethers 和 Hardhat 中，大多数操作都是异步的

比如：
- `ethers.getSigners()`：获取账户（钱包）
- `Contract.deploy()`：部署合约
- `contract.transfer()`：交易转账
- `provider.getBalance(address)`：查询余额

---

### ✅ 使用 `await` 等待异步操作

```js
const [owner, addr1] = await ethers.getSigners();  // 异步
const balance = await ethers.provider.getBalance(owner.address);  // 异步
console.log("Balance:", ethers.utils.formatEther(balance));
```

如果你**不加 `await`**，你拿到的不是结果，而是个 **Promise 对象**：

```js
const promise = ethers.provider.getBalance(owner.address);
console.log(promise);  // 输出：Promise { <pending> }
```

---

## 🧠 为什么区块链相关操作一定是异步的？

因为这些操作通常要：
1. 与区块链节点通讯
2. 等待网络确认（像转账、部署合约）
3. 查询远程链上的状态

这些都是“耗时的任务”，不能卡住主线程，只能异步处理。

---

## 🔁 小练习：部署合约时的异步链

```js
const MyContract = await ethers.getContractFactory("MyContract");
const contract = await MyContract.deploy();  // 异步：部署合约
await contract.deployed();                  // 异步：确认部署成功
console.log("Contract at:", contract.address);
```

这个流程中的每一步都必须 `await`，否则你访问 `contract.address` 时可能它还没部署好。

---

## ✅ 写异步代码的推荐风格

```js
async function main() {
  // await 一切需要网络交互的地方
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

---

## 🔄 async/await 对比 Promise 的写法

```js
// async/await（更易读）
const balance = await provider.getBalance(address);

// promise.then（更老派）
provider.getBalance(address).then((balance) => {
  console.log("Balance:", balance);
});
```

---

## 🧩 总结口诀

| 概念 | 举例 | 说明 |
|------|------|------|
| 同步 | `console.log()` | 马上执行完毕 |
| 异步 | `await ethers.getSigners()` | 网络请求、需要时间 |
| 不加 `await` | 得到 Promise | 无法直接拿到值 |
| async 函数里才能用 `await` | `async function main()` | 必须加上 async |

---
