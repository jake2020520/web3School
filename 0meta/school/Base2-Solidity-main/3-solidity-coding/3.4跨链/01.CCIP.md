# Chainlink CCIP 跨链发送 ERC20 Token 示例

CCIP官方文档地址：https://docs.chain.link/ccip



以下是一个完整的示例，展示如何使用 Chainlink 的跨链互操作性协议 (CCIP) 在不同的区块链网络之间发送 ERC20 Token。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPSender.sol";
import "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract CrossChainTokenTransferSender is CCIPSender {
    using SafeERC20 for IERC20;
    
    // 事件记录
    event TokensSent(
        bytes32 indexed messageId,
        uint64 indexed destinationChainSelector,
        address receiver,
        address token,
        uint256 tokenAmount,
        address feeToken,
        uint256 fees
    );

    constructor(address router) CCIPSender(router) {}
    
    /**
     * 发送ERC20 Token到目标链
     * @param destinationChainSelector 目标链的ChainSelector
     * @param receiver 目标链上的接收合约地址
     * @param token ERC20 Token地址
     * @param amount 发送数量
     */
    function sendToken(
        uint64 destinationChainSelector,
        address receiver,
        address token,
        uint256 amount
    ) external returns (bytes32 messageId) {
        // 转移Token到本合约
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        // 授权给路由器使用Token
        IERC20(token).safeApprove(address(i_router), amount);
        
        // 构造CCIP消息
        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: token,
            amount: amount
        });
        
        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver),
            data: "",
            tokenAmounts: tokenAmounts,
            extraArgs: "",
            feeToken: address(0) // 使用原生代币支付费用
        });
        
        // 获取费用估算
        uint256 fee = i_router.getFee(destinationChainSelector, message);
        
        // 发送跨链消息
        messageId = i_router.ccipSend(destinationChainSelector, message);
        
        emit TokensSent(
            messageId,
            destinationChainSelector,
            receiver,
            token,
            amount,
            address(0),
            fee
        );
    }
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";
import "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract CrossChainTokenTransferReceiver is CCIPReceiver {
    using SafeERC20 for IERC20;
    
    // 事件记录
    event TokensReceived(
        bytes32 indexed messageId,
        uint64 indexed sourceChainSelector,
        address sender,
        address token,
        uint256 tokenAmount
    );

    constructor(address router) CCIPReceiver(router) {}
    
    /**
     * 接收来自源链的Token
     */
    function _ccipReceive(
        Client.Any2EVMMessage memory message
    ) internal override {
        // 解析消息
        address sender = abi.decode(message.sender, (address));
        uint64 sourceChainSelector = message.sourceChainSelector;
        
        // 处理接收到的Token
        for (uint256 i = 0; i < message.tokenAmounts.length; i++) {
            Client.EVMTokenAmount memory tokenAmount = message.tokenAmounts[i];
            
            // 将Token转给消息发送者指定的接收者
            IERC20(tokenAmount.token).safeTransfer(
                abi.decode(message.receiver, (address)),
                tokenAmount.amount
            );
            
            emit TokensReceived(
                message.messageId,
                sourceChainSelector,
                sender,
                tokenAmount.token,
                tokenAmount.amount
            );
        }
    }
}
```



## 部署步骤

1. 在源链和目标链上分别部署上述合约
2. 需要传入Chainlink CCIP路由器的地址（不同链的地址不同）



## 关键参数说明

| 参数                       | 说明                                                         |
| :------------------------- | :----------------------------------------------------------- |
| `destinationChainSelector` | 目标链的唯一标识符，例如: <br>- Ethereum Mainnet: 5009297550715157269 <br>- Polygon: 4051577828743386545 |
| `i_router`                 | Chainlink CCIP路由器地址，不同链不同:<br/> - Ethereum: 0xE1053aE1857476f36A3C62580FF9b016E8EE8F6f<br/> - Polygon: 0x70499c328e1E2a3c41108bd3730F6670a44595D1 |
| `feeToken`                 | 支付费用的代币，address(0)表示使用原生代币                   |



## 注意事项

1. **费用估算**:
   - 每次发送前需要调用`getFee()`估算费用
   - 费用会随网络状况波动
2. **Token支持**:
   - 确保Token在两个链上都存在
   - 可能需要使用Chainlink的Token池服务
3. **Gas设置**:
   - 跨链交易需要足够的Gas
   - 建议使用Gas估算工具
4. **安全考虑**:
   - 只信任官方Chainlink路由器
   - 验证接收方的合约地址
5. **测试网**:
   - 先在测试网(如Sepolia、Mumbai)测试
   - 测试网路由器地址与主网不同



上面的例子是一个发送ERC20 Token的例子，其实我们可以发现他都是通过调用合约来完成的，我们可以通过写一个不同的更加复杂的合约来完成一些更加有趣的功能，而不仅仅是token传输。